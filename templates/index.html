<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SET Game — Multiplayer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <style>
    .card-container { border: 2px solid transparent; border-radius: 12px; background: white; display: flex; flex-direction: column; justify-content: center; align-items: center; box-shadow: 0 3px 6px rgba(0,0,0,0.2); transition: transform 0.2s, border-color 0.2s; aspect-ratio: 2.5 / 3.5; padding: 4px; width: 78px; height: 108px; }
    .card-container:hover { transform: scale(1.04); }
    .card-container.selected { border-color: gold; box-shadow: 0 0 10px gold; }
    .card-container.hint { border-color: #22c55e; box-shadow: 0 0 10px #22c55e; }
    .card-svg-wrapper { width: 56%; height: auto; }
    .card-svg { width: 100%; height: 100%; margin: 0 auto; overflow: visible; }
  </style>
</head>
<body class="bg-gradient-to-br from-slate-900 via-indigo-900 to-purple-900 text-white min-h-screen">
  <div id="root"></div>

  <script type="text/babel">
  const { useState, useEffect, useRef } = React;
  // Use http://localhost:1024 to connect to the backend running locally
  // For a production deployment (e.g., on Render), you would change this to `const socket = io();`
  const socket = io("http://localhost:1024");

  // --- Card logic (simpler, high-contrast symbols) ---
  const colors = ["red", "green", "blue"];
  const shapes = ["circle", "diamond", "pill"]; // easy to tell apart
  const numbers = [1, 2, 3];
  const shadings = ["solid", "striped", "open"];

  const makeDeck = (full = true) => {
    const deck = [];
    colors.forEach(c => shapes.forEach(s => numbers.forEach(n =>
      (full ? shadings : ["solid"]).forEach(sh => deck.push({ color: c, shape: s, number: n, shading: sh })))));
    // shuffle
    for (let i = deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [deck[i], deck[j]] = [deck[j], deck[i]];
    }
    return deck;
  };

  const isSet = (a, b, c) => {
    const check = key => {
      const vals = [a[key], b[key], c[key]];
      return new Set(vals).size !== 2; // not exactly-two-of-a-kind
    };
    return check("color") && check("shape") && check("number") && check("shading");
  };

  const whichFail = (a, b, c) => {
    const fails = [];
    ["color","shape","number","shading"].forEach(key => {
      const size = new Set([a[key], b[key], c[key]]).size;
      if (size === 2) fails.push(key);
    });
    return fails;
  };

  const findSet = (cards) => {
    for (let i = 0; i < cards.length - 2; i++)
      for (let j = i + 1; j < cards.length - 1; j++)
        for (let k = j + 1; k < cards.length; k++)
          if (isSet(cards[i], cards[j], cards[k])) return [i, j, k];
    return null;
  };

  const Card = ({ card, selected, hinted, onClick }) => {
    if (!card) return null;
    const stroke = card.color;
    const fill = card.shading === "solid" ? card.color : card.shading === "striped" ? `url(#pat-${card.color})` : "none";

    const offsets = { 1: [0], 2: [-14, 14], 3: [-22, 0, 22] };

    return (
      <button onClick={onClick} className={`bg-white text-black rounded-lg shadow card-container ${selected ? 'selected' : ''} ${hinted ? 'hint' : ''}`}>
        <div className="card-svg-wrapper">
          <svg viewBox="0 0 80 80" className="card-svg">
            <defs>
              {colors.map(c => (
                <pattern key={c} id={`pat-${c}`} patternUnits="userSpaceOnUse" width="8" height="8">
                  <path d="M0 8 L8 0" stroke={c} strokeWidth="1" />
                </pattern>
              ))}
            </defs>

            {offsets[card.number].map((dy, i) => (
              <g key={i} transform={`translate(0, ${dy})`}>
                {card.shape === "circle" && (
                  <circle cx="40" cy="40" r="14" fill={fill} stroke={stroke} strokeWidth="2" />
                )}
                {card.shape === "diamond" && (
                  <polygon points="40,18 62,40 40,62 18,40" fill={fill} stroke={stroke} strokeWidth="2" />
                )}
                {card.shape === "pill" && (
                  <rect x="22" y="26" width="36" height="28" rx="12" ry="12" fill={fill} stroke={stroke} strokeWidth="2" />
                )}
              </g>
            ))}
          </svg>
        </div>
      </button>
    );
  };

  // --- Main App ---
  const App = () => {
    const [deck, setDeck] = useState([]);
    const [table, setTable] = useState([]);
    const [selected, setSelected] = useState([]);
    const [hinted, setHinted] = useState([]);
    const [message, setMessage] = useState('');
    const [timer, setTimer] = useState(0);
    const [playerName, setPlayerName] = useState('');
    const [gameId, setGameId] = useState(null);
    const [isHost, setIsHost] = useState(false);
    const [gameStarted, setGameStarted] = useState(false);
    const [players, setPlayers] = useState([]);
    const [showTutorial, setShowTutorial] = useState(true);
    const timerRef = useRef(null);

    // helper to normalize players payloads from server
    const normalizePlayers = (arr) => {
      if (!Array.isArray(arr)) return [];
      return arr.map(p => {
        if (typeof p === 'string') return { name: p, score: 0 };
        return { name: p.name ?? 'Player', score: p.score ?? 0 };
      });
    };

    useEffect(() => {
      if (gameStarted) {
        if (!timerRef.current) {
          timerRef.current = setInterval(() => setTimer(t => t + 1), 1000);
        }
      } else {
        clearInterval(timerRef.current);
        timerRef.current = null;
      }
      return () => clearInterval(timerRef.current);
    }, [gameStarted]);

    useEffect(() => {
      socket.on("room_created", (data) => {
        setGameId(data.room_id);
        setIsHost(true);
        setMessage(`Room created: ${data.room_id}`);
      });

      socket.on("game_state", (state) => {
        setDeck(state.deck || []);
        setTable(state.table || []);
        setGameStarted(!!state.gameStarted);
        if (state.players) {
          const sortedPlayers = normalizePlayers(state.players).sort((a,b) => (b.score ?? 0) - (a.score ?? 0));
          setPlayers(sortedPlayers);
        }
      });

      socket.on("scoreboard", (updatedPlayers) => {
        const list = normalizePlayers(updatedPlayers);
        if (list.length) {
          list.sort((a, b) => (b.score ?? 0) - (a.score ?? 0));
          setPlayers(list);
        }
      });
      
      socket.on("error", (data) => {
        setMessage(`Error: ${data.message}`);
      });

      return () => {
        socket.off("room_created");
        socket.off("game_state");
        socket.off("scoreboard");
        socket.off("error");
      };
    }, []);

    const startGame = (full = true) => {
      const d = makeDeck(full);
      const initDeck = d.slice(12);
      const initTable = d.slice(0, 12);
      setTimer(0);
      setShowTutorial(false);
      setSelected([]); setHinted([]); setMessage('');
      
      if (gameId) {
        socket.emit("start_game", { room: gameId, game_data: { deck: initDeck, table: initTable, gameStarted: true } });
      } else {
        // Single player mode
        setDeck(initDeck);
        setTable(initTable);
        setGameStarted(true);
        setPlayers([{ name: playerName || 'You', score: 0 }]);
      }
    };

    const clickCard = idx => {
      if (selected.includes(idx)) setSelected(selected.filter(i => i !== idx));
      else if (selected.length < 3) setSelected([...selected, idx]);
    };

    const submitSet = () => {
      if (selected.length !== 3) {
        alert("⚠️ You must select exactly 3 cards before submitting!");
        return;
      }
      const [a, b, c] = selected.map(i => table[i]);
      if (!a || !b || !c) return; // safety
      if (isSet(a, b, c)) {
        const remaining = table.filter((_, i) => !selected.includes(i));
        const newCards = deck.slice(0, 3);
        const newTable = [...remaining, ...newCards];
        const newDeck = deck.slice(3);
        
        if (gameId) {
          socket.emit("submit_set", { room: gameId, username: playerName || 'You', newDeck, newTable });
        } else {
          setDeck(newDeck);
          setTable(newTable);
          setPlayers(prev => prev.map(p => p.name === (playerName || 'You') ? { ...p, score: (p.score || 0) + 1 } : p));
        }

        setMessage("✅ Set found!");
        const noMoreCards = newDeck.length === 0;
        const noMoreSets = findSet(newTable) === null;
        if (noMoreCards && noMoreSets) {
          const winner = [...players].sort((x, y) => (y.score||0) - (x.score||0))[0] || { name: playerName || 'You', score: 0 };
          setTimeout(() => alert(`🎉 Game Over! Winner is ${winner.name} with ${winner.score} points!`), 50);
        }
      } else {
        const fails = whichFail(a, b, c);
        alert(`❌ Not a set! Conflicts in: ${fails.join(', ') || 'unknown'}`);
      }
      setSelected([]); setHinted([]);
    };

    const hint = () => {
      const foundSet = findSet(table);
      if (foundSet) setHinted(foundSet);
      else setMessage("No set found.");
    };

    const dealThree = () => {
      if (!deck.length) return setMessage("No more cards!");
      const newTable = [...table, ...deck.slice(0, 3)];
      const newDeck = deck.slice(3);
      if (gameId) {
        socket.emit("deal_three", { room: gameId, newDeck, newTable });
      } else {
        setTable(newTable);
        setDeck(newDeck);
      }
    };

    const createMultiplayer = () => {
      if (!playerName) return setMessage("Enter your name first!");
      socket.emit("create_room", { username: playerName });
    };

    const joinMultiplayer = (joinCode) => {
      if (!playerName || !joinCode) return setMessage("Enter name + code!");
      setGameId(joinCode);
      socket.emit("join_room", { username: playerName, room: joinCode });
    };

    return (
      <div className="p-4 flex flex-col items-center">
        <h1 className="text-2xl font-bold mb-2">SET Game</h1>

        {showTutorial && !gameStarted && (
          <div className="bg-gray-800 p-4 rounded mb-4 max-w-md text-left">
            <h2 className="font-bold text-lg mb-2">How to Play</h2>
            <ul className="list-disc list-inside text-sm space-y-1">
              <li>Each card has a color, shape, number, and shading.</li>
              <li>A set is 3 cards where each feature is either all the same or all different.</li>
              <li>Select 3 cards and click "Submit Set".</li>
              <li>You can request a hint or deal 3 more cards if needed.</li>
              <li>Game ends when no sets remain and the deck is empty.</li>
            </ul>
          </div>
        )}

        <div className="text-center mb-4">
          Timer: {String(Math.floor(timer / 60)).padStart(2,'0')}:{String(timer % 60).padStart(2,'0')}
          <span className="ml-4">Cards: {table.length} / {table.length + deck.length}</span>
        </div>

        {!gameStarted && !gameId ? (
          <div className="flex flex-col items-center gap-4">
            <input value={playerName} onChange={e => setPlayerName(e.target.value)} placeholder="Enter your name" className="text-black rounded px-2 py-1"/>
            <button onClick={() => startGame(true)} className="bg-blue-500 px-3 py-1 rounded">Single Player (81 Cards)</button>
            <button onClick={() => startGame(false)} className="bg-purple-500 px-3 py-1 rounded">Single Player (27 Cards)</button>
            <button onClick={createMultiplayer} className="bg-green-500 px-3 py-1 rounded">Create Multiplayer</button>
            <div className="flex items-center gap-2">
              <input id="joinCode" placeholder="Game Code" className="text-black rounded px-2 w-28"/>
              <button onClick={() => joinMultiplayer(document.getElementById('joinCode').value)} className="bg-green-700 px-3 py-1 rounded">Join Multiplayer</button>
            </div>
          </div>
        ) : (
          <>
            {isHost && !gameStarted && (
              <div className="mt-4 p-4 bg-gray-800 rounded text-center">
                <p className="mb-1">Game ID: <span className="font-mono">{gameId}</span></p>
                <p>Select mode:</p>
                <button onClick={() => startGame(false)} className="bg-purple-500 px-3 py-1 m-1 rounded">27 Cards</button>
                <button onClick={() => startGame(true)} className="bg-purple-700 px-3 py-1 m-1 rounded">81 Cards</button>
              </div>
            )}

            <div className="bg-gray-800 p-3 rounded mb-3 w-80 text-center">
              <h2 className="font-bold mb-2 text-lg">Scoreboard</h2>
              {players.length === 0 ? (
                <p className="text-sm text-gray-300">No players yet</p>
              ) : (
                <ul className="space-y-1">
                  {players.map((p, i) => (
                    <li key={i} className="flex justify-between px-2">
                      <span className="font-medium text-left truncate max-w-[60%]">{p.name}</span>
                      <span className="font-semibold">{p.score ?? 0}</span>
                    </li>
                  ))}
                </ul>
              )}
            </div>

            <div className="flex gap-2 my-3">
              <button onClick={dealThree} className="bg-yellow-500 px-3 py-1 rounded">Deal 3</button>
              <button onClick={submitSet} className="bg-green-500 px-3 py-1 rounded">Submit Set</button>
              <button onClick={hint} className="bg-yellow-400 px-3 py-1 rounded">Hint</button>
            </div>

            {message && <p className="mb-2">{message}</p>}
            <div className="grid grid-cols-3 gap-3">
              {table.map((card, idx) => (
                <Card key={idx} card={card} selected={selected.includes(idx)} hinted={hinted.includes(idx)} onClick={() => clickCard(idx)}/>
              ))}
            </div>
          </>
        )}
      </div>
    );
  };

  ReactDOM.createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>
</html>
