<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SET Game — Multiplayer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
</head>
<body class="bg-gradient-to-br from-slate-900 via-indigo-900 to-purple-900 text-white min-h-screen">
  <div id="root"></div>

  <script type="text/babel">
  const { useState, useEffect, useRef } = React;
  const socket = io("http://localhost:4000");

  const colors = ["red", "green", "blue"];
  const shapes = ["circle", "diamond", "pill"];
  const numbers = [1, 2, 3];
  const shadings = ["solid", "striped", "open"];

  const makeDeck = (full = true) => {
    const deck = [];
    colors.forEach(c => shapes.forEach(s => numbers.forEach(n =>
      (full ? shadings : ["solid"]).forEach(sh => deck.push({ color: c, shape: s, number: n, shading: sh })))));
    for (let i = deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [deck[i], deck[j]] = [deck[j], deck[i]];
    }
    return deck;
  };

  const isSet = (a, b, c) => {
    const check = key => {
      const vals = [a[key], b[key], c[key]];
      return new Set(vals).size !== 2;
    };
    return check("color") && check("shape") && check("number") && check("shading");
  };

  const findSet = (cards) => {
    for (let i = 0; i < cards.length - 2; i++)
      for (let j = i + 1; j < cards.length - 1; j++)
        for (let k = j + 1; k < cards.length; k++)
          if (isSet(cards[i], cards[j], cards[k])) return [i, j, k];
    return null;
  };

  const Card = ({ card, selected, hinted, onClick }) => {
    if (!card) return null;
    const stroke = card.color;
    const fill = card.shading === "solid" ? card.color : card.shading === "striped" ? `url(#pat-${card.color})` : "none";
    const offsets = { 1: [0], 2: [-14, 14], 3: [-22, 0, 22] };

    return (
      <button onClick={onClick} className={`bg-white text-black rounded-lg shadow card-container ${selected ? 'selected' : ''} ${hinted ? 'hint' : ''}`}>
        <div className="card-svg-wrapper">
          <svg viewBox="0 0 80 80" className="card-svg">
            <defs>
              {colors.map(c => (
                <pattern key={c} id={`pat-${c}`} patternUnits="userSpaceOnUse" width="8" height="8">
                  <path d="M0 8 L8 0" stroke={c} strokeWidth="1" />
                </pattern>
              ))}
            </defs>
            {offsets[card.number].map((dy, i) => (
              <g key={i} transform={`translate(0, ${dy})`}>
                {card.shape === "circle" && (
                  <circle cx="40" cy="40" r="14" fill={fill} stroke={stroke} strokeWidth="2" />
                )}
                {card.shape === "diamond" && (
                  <polygon points="40,18 62,40 40,62 18,40" fill={fill} stroke={stroke} strokeWidth="2" />
                )}
                {card.shape === "pill" && (
                  <rect x="22" y="26" width="36" height="28" rx="12" ry="12" fill={fill} stroke={stroke} strokeWidth="2" />
                )}
              </g>
            ))}
          </svg>
        </div>
      </button>
    );
  };

  const App = () => {
    const [deck, setDeck] = useState([]);
    const [table, setTable] = useState([]);
    const [selected, setSelected] = useState([]);
    const [hinted, setHinted] = useState([]);
    const [message, setMessage] = useState('');
    const [timer, setTimer] = useState(0);
    const [playerName, setPlayerName] = useState('');
    const [gameId, setGameId] = useState(null);
    const [isHost, setIsHost] = useState(false);
    const [gameStarted, setGameStarted] = useState(false);
    const [players, setPlayers] = useState([]);
    const [showTutorial, setShowTutorial] = useState(true);
    const timerRef = useRef(null);

    const normalizePlayers = (arr) => {
      if (!Array.isArray(arr)) return [];
      return arr.map(p => {
        if (typeof p === 'string') return { name: p, score: 0 };
        if (p && p.username && !p.name) return { name: p.username, score: p.score ?? 0 };
        return { name: p.name ?? 'Player', score: p.score ?? 0 };
      });
    };

    useEffect(() => {
      if (gameStarted) {
        if (!timerRef.current) {
          timerRef.current = setInterval(() => setTimer(t => t + 1), 1000);
        }
      } else {
        clearInterval(timerRef.current);
        timerRef.current = null;
      }
      return () => {};
    }, [gameStarted]);

    useEffect(() => {
      socket.on("room_created", (data) => {
        setGameId(data.room_id);
        setIsHost(true);
        setPlayers(prev => prev.length ? prev : [{ name: playerName || 'You', score: 0 }]);
        setMessage(`Room created: ${data.room_id}`);
      });

      socket.on("player_joined", (data) => {
        const list = normalizePlayers(data.players);
        setPlayers(list.length ? list : [{ name: playerName || 'You', score: 0 }]);
        setMessage(`Player joined: ${data.username || ''}`);
        if (isHost) {
          socket.emit("sync_state", { room: gameId, deck, table, gameStarted });
        }
      });

      socket.on("game_state", (state) => {
        setDeck(state.deck || []);
        setTable(state.table || []);
        setGameStarted(!!state.gameStarted);
      });

      socket.on("scoreboard", (updatedPlayers) => {
        const list = normalizePlayers(updatedPlayers);
        if (list.length) {
          list.sort((a, b) => (b.score ?? 0) - (a.score ?? 0));
          setPlayers(list);
        }
      });

      // 🎉 Handle game over
      socket.on("game_over", ({ winner }) => {
        setMessage(`🎉 Game Over! Winner is ${winner.name} with ${winner.score} points!`);
        alert(`🎉 Game Over! Winner is ${winner.name} with ${winner.score} points!`);
        setGameStarted(false);
      });

      return () => {
        socket.off("room_created");
        socket.off("player_joined");
        socket.off("game_state");
        socket.off("scoreboard");
        socket.off("game_over");
      };
    }, [playerName, isHost, deck, table, gameId, gameStarted]);

    const broadcastState = (newDeck, newTable, started = true) => {
      setDeck(newDeck);
      setTable(newTable);
      setGameStarted(started);
      if (gameId) {
        socket.emit("update_state", { room: gameId, deck: newDeck, table: newTable, gameStarted: started });
      }
    };

    const ensureSelfInPlayers = () => {
      setPlayers(prev => {
        if (prev.length === 0) return [{ name: playerName, score: 0 }];
        const hasSelf = prev.some(p => p.name === playerName);
        return hasSelf ? prev : [...prev, { name: playerName, score: 0 }];
      });
    };

    const startGame = (full = true) => {
      const d = makeDeck(full);
      const initDeck = d.slice(12);
      const initTable = d.slice(0, 12);
      broadcastState(initDeck, initTable, true);
      setSelected([]); setHinted([]); setMessage('');
      setTimer(0);
      setShowTutorial(false);
      ensureSelfInPlayers();
    };

    const clickCard = idx => {
      if (selected.includes(idx)) setSelected(selected.filter(i => i !== idx));
      else if (selected.length < 3) setSelected([...selected, idx]);
    };

    const submitSet = () => {
      if (selected.length !== 3) {
        alert("⚠️ You must select exactly 3 cards before submitting!");
        return;
      }
      const [a, b, c] = selected.map(i => table[i]);
      if (!a || !b || !c) return;
      if (isSet(a, b, c)) {
        const remaining = table.filter((_, i) => !selected.includes(i));
        const newCards = deck.slice(0, 3);
        const newTable = [...remaining, ...newCards];
        const newDeck = deck.slice(3);
        broadcastState(newDeck, newTable);
        setPlayers(prev => prev.map(p => p.name === (playerName || 'You') ? { ...p, score: (p.score || 0) + 1 } : p));
        if (gameId) socket.emit("score_update", { room: gameId, username: playerName || 'You' });
        setMessage("✅ Set found!");
      } else {
        alert("❌ Not a set!");
      }
      setSelected([]); setHinted([]);
    };

    const hint = () => {
      const foundSet = findSet(table);
      if (foundSet) setHinted(foundSet);
      else setMessage("No set found.");
    };

    const dealThree = () => {
      if (!deck.length) return setMessage("No more cards!");
      const newTable = [...table, ...deck.slice(0, 3)];
      const newDeck = deck.slice(3);
      broadcastState(newDeck, newTable);
    };

    const createMultiplayer = () => {
      if (!playerName) return setMessage("Enter your name first!");
      socket.emit("create_room", { username: playerName });
      ensureSelfInPlayers();
    };

    const joinMultiplayer = (joinCode) => {
      if (!playerName || !joinCode) return setMessage("Enter name + code!");
      socket.emit("join_room", { username: playerName, room: joinCode });
      setGameId(joinCode);
      ensureSelfInPlayers();
    };

    return (
      <div className="p-4 flex flex-col items-center">
        <h1 className="text-2xl font-bold mb-2">SET Game</h1>

        <div className="text-center mb-4">
          Timer: {String(Math.floor(timer / 60)).padStart(2,'0')}:{String(timer % 60).padStart(2,'0')}
          <span className="ml-4">Cards: {table.length} / {table.length + deck.length}</span>
        </div>

        {!gameStarted && !gameId ? (
          <div className="flex flex-col items-center gap-4">
            <input value={playerName} onChange={e => setPlayerName(e.target.value)} placeholder="Enter your name" className="text-black rounded px-2 py-1"/>
            <button onClick={() => startGame(true)} className="bg-blue-500 px-3 py-1 rounded">Single Player (81 Cards)</button>
            <button onClick={() => startGame(false)} className="bg-purple-500 px-3 py-1 rounded">Single Player (27 Cards)</button>
            <button onClick={createMultiplayer} className="bg-green-500 px-3 py-1 rounded">Create Multiplayer</button>
            <div className="flex items-center gap-2">
              <input id="joinCode" placeholder="Game Code" className="text-black rounded px-2 w-28"/>
              <button onClick={() => joinMultiplayer(document.getElementById('joinCode').value)} className="bg-green-700 px-3 py-1 rounded">Join Multiplayer</button>
            </div>
          </div>
        ) : (
          <>
            <div className="bg-gray-800 p-3 rounded mb-3 w-80 text-center">
              <h2 className="font-bold mb-2 text-lg">Scoreboard</h2>
              {players.length === 0 ? (
                <p className="text-sm text-gray-300">No players yet</p>
              ) : (
                <ul className="space-y-1">
                  {players.map((p, i) => (
                    <li key={i} className="flex justify-between px-2">
                      <span className="font-medium text-left truncate max-w-[60%]">{p.name}</span>
                      <span className="font-semibold">{p.score ?? 0}</span>
                    </li>
                  ))}
                </ul>
              )}
            </div>

            <div className="flex gap-2 my-3">
              <button onClick={dealThree} className="bg-yellow-500 px-3 py-1 rounded">Deal 3</button>
              <button onClick={submitSet} className="bg-green-500 px-3 py-1 rounded">Submit Set</button>
              <button onClick={hint} className="bg-yellow-400 px-3 py-1 rounded">Hint</button>
            </div>

            {message && <p className="mb-2">{message}</p>}
            <div className="grid grid-cols-3 gap-3">
              {table.map((card, idx) => (
                <Card key={idx} card={card} selected={selected.includes(idx)} hinted={hinted.includes(idx)} onClick={() => clickCard(idx)}/>
              ))}
            </div>
          </>
        )}
      </div>
    );
  };

  ReactDOM.createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>
</html>
